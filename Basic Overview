= The Tap Application (Tap::App)

Instances of Tap::App coordinate the execution of tasks.  Normally a script will only need and use a single instance (often Tap::App.instance), but there is no reason why multiple instances could not be used.  Apps basically consist of reference to a root directory, and task queue.  

=== Root Directory (Tap::Root)

The root directory establishes the base of a standard directory structure that facilitates configuration, dependency loading, and file handling.  Apps 'live' in the directory structure, but are not confined to it.  Code associated with the root directory allows you to alias directories, basically meaning that the conceptual standard directories can be put anywhere in the file system.  

The basic structure looks like this:

  /path/to/root_dir
  |- config
  |   `- sample
  |       `- task.yml             # a default config file for Sample::Task
  |- lib
  |   `- sample
  |       `- task.rb              # a class file like above
  |- tap.yml                      # a configuration file for Tap::App

All these files/directories are optional (and there are others that could be added), but for illustration say you instantiated an App to the directory above:

  require 'tap'
  
  app = Tap::App.new :root => '/path/to/root_dir'
  app.root                                      # => '/path/to/root_dir'
  app['config']                                 # => '/path/to/root_dir/config'
  app.filepath('config', 'sample/task.yml')     # => '/path/to/root_dir/config/sample/task.yml'
  
Then if you wanted to alias the config directory somewhere else:

  # set a new directory relative to root
  app['config'] = 'alt'
  app['config']                                 # => '/path/to/root_dir/alt'
  app.filepath('config', 'sample/task.yml')     # => '/path/to/root_dir/alt/sample/task.yml'
  
  # set an absolute path to anywhere
  app['config', true] = '/path/somewhere/else'
  app['config']                                 # => '/path/somewhere/else'
  app.filepath('config', 'sample/task.yml')     # => '/path/somewhere/else/sample/task.yml'
  
While very simple, this ability to reference files using directory aliases is useful, powerful, and forms the basis of the Tap execution environment.  All directory aliases and environment configurations can be defined in the 'tap.yml' file.

=== Task Queue

Apps coordinate the execution of tasks through a queue.  Although referred to here as a 'task queue', the queue is actually just a stack of methods to run and the inputs to the methods.  Any methods from any object can be enqued; tasks do not need to be involved.  

During a run the enqued methods are run sequentially.  When multithreading, multiple methods can be run at once, but normally methods are run one at a time on the same thread.  

= Tasks (Tap::Task)

Tasks can be defined within a script using a syntax similar to Rake:

  t = Tap::Task.new do |task|
    # .. do something ...
  end
  t.execute
  
Unlike a Rake task, Tap tasks can be made to take inputs:

  t = Tap::Task.new do |task, one, two|
    # .. do something with the inputs ...
  end
  t.execute(1,2)
  
Tasks are designed for subclassing.  A task class is structured like this (with annotation):
  
  module Sample
    # == Description
    # This documentation is available in RDoc, as well as from the command line.
    # === Usage
    #  % tap run sample/task
    #
    # By default, usage info comes up as well...
    #
    class Task < Tap::Task

      # Configurations are defined like this.  Tap makes
      # the config documentation available in Rdoc and
      # in the command line.
      #
      # The default 'config' creates accessors, as can 
      # be seen in the process method.
      
      # Full documentation for the configuration
      # can be written here.
      config :key, "input"                            # command line documentation
      
      # Configurations can be transformed or 
      # validated by an optional block.
      config :transformation, "string" do |value|     # this config is modified to "STRING"
        value.upcase
      end
      config :standard_validation, {}, &c.check(Hash) # non-hash values raise an error
    
      # Process receives each input from the command line
      # and is analogous to the block in the samples above.
      # Any number of inputs are allowed, including an 
      # arbitrary number of inputs (using *) and no inputs.
      def process(input)
      
        # log is available to record information
        result = "#{input} was processed with #{key}"
        log self.name, result

        result
      end
    end
  end

Once instantiated, tasks can be enqued to an App or joined into a workflow.  
      
All task instances may have a name, which serves as a relative filepath to a configuration file and other associated files.  When the application instantiates a task by the name 'sample/task' it sets the instance configs from 'config/sample/task.yml'.  Nil can be used to specify no config file. 

Names need not be unique.  Multiple task instances, even from different classes, may be named the same and thus get their configurations from the same file.  A map of task names to task classes can be set up in an app, allowing easy lookup and task instantiation through the app.task method:

  app = Tap:App.instance

  # set up a mapping between a name and a task class
  app.map["alt"] = Sample::Task 

  t1 = app.task("sample/task")     # Sample::Task configured from 'config/sample/task.yml'
  t2 = app.task("alt")             # Sample::Task configured from 'config/alt.yml'
  
  # the idea is the same if you manually make a task... 

  t3 = Tap::Task.new("alt")        # Tap::Task configured from 'config/alt.yml'
  
  t1.class     # => Sample::Task
  t2.class     # => Sample::Task
  t3.class     # => Tap::Task

= Workflows (Tap::Workflow)

Once instantiated, tasks can be joined into workflows.  The workflow model used by Tap is very simple; workflows are implemented using the App queue, whereby each tasks enques the next task (or tasks) in the workflow when the task completes.  

Each task can be assigned an on_complete block to do so.  Arbitrary workflow logic can be used to join tasks in this way, but by default Tap supports sequencing, forking, and merging.  If a task has no on_complete block, App collects the unhandled results in app.aggregator so they can be handled somewhere else.

Workflows are not Tasks, but work exactly like Tasks.  Workflows can be configured, enqued, used in or joined to other workflows, and subclassed.

= Auditing (Tap::Support::Audit)

Tap tracks inputs as they are modified by various tasks.  At the end of a run, the individual results can be tracked back to it's original value, through the tasks that modified it.  This auditing can be very useful when workflows diverge (as they often do), adding or subtracting steps depending on the input.

Auditing is largely invisible except in on_complete blocks.  On complete blocks receive the audited results so that this information can be used, as needed, to make decisions.  

  t = Task.new
  t.on_complete do |_result|      # _result is an Audit instance
    _result._current              # the current value
    _result._original             # the original value
  end

