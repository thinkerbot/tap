= Syntax Reference

== Task Declarations

A task declaration:

  # name::           the name of the task, either alone or as the
  #                  key of a {key => dependencies} hash
  # dependencies::   an array of task names (optional)
  # arg_names::      an array of argument names (optional)
  # configurations:: a hash of {key => default} pairs (optional)

  task({<name> => [<dependencies...>]}, <arg_names...>, {<configs>}) do |task, args|
    # arguments are available through args:
    args.arg_name
    
    # configurations are available through task
    task.key
  end

A namespace declaration:

  namespace(<name>) { task ... }
 
Simple documentation:
 
  desc "description"
  task ...
  
Extended documentation:
  
  # ::desc description
  # Extended documentation may span multiple lines, and 
  # supports
  #
  #   code indentation
  #   like this.
  #
  # Lines are justified and wrapped on the command line.
  task ...

Pains were taken to make task declarations for rap work the similar to rake
tasks.  In both cases (noting that in general, beyond rap, task classes are
not limited in these ways):

* tasks are singleton instances that may be extended across multiple
  declarations
* tasks do not pass inputs from one task to the next
* tasks only execute once

A few syntactical differences between rake and rap must to be noted, as they
can cause errors if you try to migrate rake tasks to tap.

==== no needs

Rap does not support :needs as a way to specify dependencies.  For instance,
this will declare a ':needs' configuration with the default value ':another',
not a task which depends on another:

  Rap.task :name, :needs => :another

==== immediate namespace lookup

Within a namespace, task will look for a literal match to the dependency first.
If it doesn't find one, it will declare it within the namespace; one way or the
other the dependency is resolved to a constant immediately.  Hence, in this
example the nested task depends on the non-nested task.  

  task :outer { print 'non-nested' }
  namespace :nest do
    task :inner => :outer { puts 'was executed' }
    task :outer { print 'nested' }
  end
  
By contrast, rake waits to resolve dependencies and will always use a match
within a namespace in preference to a literal match.  For these tasks rap and
rake produce different results:

  % rap nest/inner
  non-nested was executed
  % rake nest:inner
  nested was executed