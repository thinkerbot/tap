= Tap (Task Application)

Tap is a framework for creating configurable, distributable tasks and workflows.  Although scalable for complex workflows, at it simplest tap is just a supercharged rake.  Using the rap (rakish-app) executable, you can declare and run tasks using a syntax almost identical to rake, but with added support for configurations and documentation.  Going beyond rap, tap offers:

* task classes
* imperative workflows
* generators
* testing
* distribution of task libraries as gems.   

== Quickstart

If you've used rake, tap will be easy to pick up.  To get started, make a Tapfile with a simple task declaration:

  [Tapfile]
    
  # ::desc your basic goodnight moon task
  # Says goodnight with a configurable message.
  Tap.task(:goodnight, :obj, :message => 'goodnight') do |task, args|
    puts "#{task.message} #{args.obj}"
  end
  
Now from the command line:

  % rap goodnight moon
  goodnight moon
  % rap goodnight world --message hello
  hello world
  % rap goodnight --help
  Goodnight -- your basic goodnight moon task
  --------------------------------------------------------------------------------
    Says goodnight with a configurable message.
  --------------------------------------------------------------------------------
  usage: tap run -- goodnight obj

  configurations:
          --message MESSAGE

  options:
      -h, --help                       Print this help
          --name NAME                  Specify a name
          --use FILE                   Loads inputs from file
  
Just like that you have a miniature command-line app with inputs, configuration, and documentation.  The declaration syntax is obviously similar to rake; the configurations are new, but the declaration uses the same task-block style as rake, and handles inputs the same.  Other rake constructs are also available.  Here is a similar goodnight task, with dependencies, rake-style.

  [Tapfile]
  
  # make the declarations available everywhere
  # (normally they're accessed via Tap, as above)
  extend Tap::Declarations
  
  namespace :example do
    task(:say, :message) do |task, args|
      print(args.message || 'goodnight')
    end
    
    desc "your basic goodnight moon task"
    task({:goodnight => :say}, :obj) do |task, args|
      puts " #{args.obj}"
    end
  end

And now from the command line: 

  % rap goodnight moon
  goodnight moon
  % rap goodnight world --* say hello
  hello world

Something new!  Unlike rake, rap inputs are simply written out for each task, and the tasks are delimited by a modified double-dash (in this case --*, more on this later).

At this point, rap is acting like a supercharged rake; rake but with configurations, simpler inputs, and extended documentation.  The declaration syntax is similar enough that, in many cases, renaming Rakefile and adding Tap::Declarations will be sufficient to convert a set of rake tasks into tap tasks.  (Note: even that step isn't absolutely necessary; rap tries to run unknown task using rake.  Simply substitute rap for rake on the command line and your tasks should launch as normal.)

However, supercharging rake isn't the point of Tap.  The declarative tasks used by rap are really just a bridge spanning the gap between rake and tap; tap itself is a more general task framework.  To get at the other key features of tap like imperative workflows, testing, and distribution, we have to go beyond rap and take a look at what declarations are doing.

== Beyond Rap

Task declarations make subclasses of Tap::Task.  Going back to the first example, lets take a look at how a declaration maps to a class definition:

  [Tapfile]
  # ::desc your basic goodnight moon task
  # Says goodnight with a configurable message.
  Tap.task(:goodnight, :obj, :message => 'goodnight') do
    puts "#{task.message} #{args.obj}"
  end
  
Here is a corresponding class definition:

  [Tapfile]
  # Goodnight::manifest your basic goodnight moon task
  # Says goodnight with a configurable message.
  class Goodnight < Tap::Task
    config :message, 'goodnight'

    def process(obj)
      "#{message} #{obj}"
    end
  end

Simple enough.  The name corresponds to the class, configurations (and dependencies, although they aren't show) are written out individually, and the block corresponds to process.  There are a few subtle differences, however, especially relating to process... but for the moment lets gloss over them and see how Goodnight works.

  # the class tracks the default configs
  
  Goodnight.configurations.to_hash         # => {:message => 'goodnight'}
  
  # instances have accessors for the configs
  
  goodnight = Goodnight.new
  goodnight.message                        # => 'goodnight'
  goodnight.process('moon')                # => 'goodnight moon'
  
  # overrides may be specified during initialization
  
  hello = Goodnight.new(:message => 'hello')
  hello.message                            # => 'hello'
  hello.process('world')                   # => 'hello world'

When it comes time to make a workflow, instances may be joined using a variety of methods (sequence, fork, switch, merge, and sync_merge are supported by default).  To run a workflow, use +execute+.  The results of one task are passed as the inputs of the next task and the final results are collected by the underlying Tap::App.

  hello.sequence(goodnight)
  hello.execute('world')

  app = Tap::App.instance
  app.results(goodnight)                   # => ["goodnight hello world"]

If you think about what's going on the result makes sense.  The hello task modifies 'world' to make 'hello world' and that becomes the input to the goodnight task.  Tracking logic through two tasks isn't tough, but for many tasks it can be complex.  To help out, all workflows are audited.

  # this is the audit for the result
  audit = app._results(goodnight)[0]
  audit._current                           # => "goodnight hello world"
  
  # _to_s prints the audit trail
  "\n#{audit._to_s}"
  # => %Q{
  # o-[] "world"
  # o-[goodnight] "hello world"
  # o-[goodnight] "goodnight hello world"
  # }
  
Ah!  Now the workflow is clear.  The same workflow may be built from the command line:

  % rap goodnight world --message hello --: goodnight --+ dump
  # audit:
  # o-[] "world"
  # o-[goodnight] "hello world"
  # o-[goodnight] "goodnight hello world"
  # 
  # date: 2008-10-09 11:21:08
  --- 
  goodnight (2724600): 
  - goodnight hello world

Task declarations cannot pass inputs like this; they're second-class citizens for imperative workflows.  What's more, declarations simply cannot do all the things possible in a class definitions.  In a class definition, for example, variable inputs and inputs with defaults may be specified for process.  Configurations can be documented, and they support validation/transformation blocks (the most common of which are available through the +c+ method, an alias for the Tap::Support::Validation module).

  [Tapfile]
  # Goodnight::manifest a fancy goodnight moon task
  # Says goodnight with a configurable message.
  class Goodnight < Tap::Task
    config :message, 'goodnight'           # a goodnight message
    config :reverse, false, &c.switch      # reverses the message
    config :n, 1, &c.integer               # repeats message n times
    
    def process(*objects)
      print "#{reverse == true ? message.reverse : message} " * n
      puts objects.join(', ')
      puts
    end
  end

Now from the command line:
  
  % rap goodnight moon
  goodnight moon
  
  % rap goodnight moon mittens "little toy boat"
  goodnight moon, mittens, little toy boat
  
  % rap goodnight world --message hello --reverse --n 3 
  olleh olleh olleh world
  
  % rap goodnight --help
  Goodnight -- a fancy goodnight moon task
  --------------------------------------------------------------------------------
    Says goodnight with a configurable message.
  --------------------------------------------------------------------------------
  usage: tap run -- goodnight OBJECTS...

  configurations:
          --message MESSAGE            a goodnight message
          --[no-]reverse               reverses the message
          --n N                        repeats message n times

  options:
      -h, --help                       Print this help
          --name NAME                  Specify a name
          --use FILE                   Loads inputs from file

By the outputs you can see the string configurations are transformed into the proper objects by the time process is run.  In addition, take a quick look at the documentation.  The usage now has configuration documentation, and reverse is a switch.  The rich mapping of a class declaration to the command line allows tasks to act as an script interface, not unlike OptParse.  For example you could use this as a stand-alone script:

  [goodnight]
  #!/usr/bin/env ruby
  
  require 'rubygems'
  require 'tap'

  # Goodnight::manifest a goodnight moon script
  # Says goodnight with a configurable message.
  class Goodnight < Tap::Task
    config :message, 'goodnight'

    def process(obj)
      puts "#{message} #{obj}"
    end
  end

  instance, args = Goodnight.parse!(ARGV)
  instance.execute(*args)
  
Now, from the command line:

  % ./goodnight moon
  goodnight moon
  % ./goodnight --help
  ...
  
Nonetheless, the use of tasks on the command line should not eclipse the basic fact that tasks are normal, predictable objects.  Task classes subclass normally, instances don't need rap, or a Tapfile.  Until you use one of the Tap executables, tasks constructed by class definitions are normal parts of a library which may be tested and distributed as usual.

==== Generators, Testing, Distribution

Beyond rap is tap.  The tap executable is more verbose than rap for running tasks, but it is ultimately more capable, scalable, and logically pure.  The easiest way to get a feel for Tap is to see it in action.

Tap comes with a number of command, but we'll use generate to make, test, and package a task library.  Begin by creating a tap directory structure and a task:

  % tap generate root sample
  % cd sample
  % tap generate task goodnight

Take a look at the task files an you find something like this:

  [lib/goodnight.rb]
  # Goodnight::manifest <replace with manifest summary>
  # <replace with command line description>

  # Goodnight Documentation
  class Goodnight < Tap::Task

    # <config file documentation>
    config :message, 'goodnight'           # a sample config
  
    def process(name)
      log message, name
      "#{message} #{name}"
    end
  end 

  [test/goodnight_test.rb]
  require File.join(File.dirname(__FILE__), 'tap_test_helper.rb') 
  require 'goodnight'

  class GoodnightTest < Test::Unit::TestCase
    acts_as_tap_test 

    def test_goodnight
      task = Goodnight.new :message => "goodnight"

      # a simple test
      assert_equal({:message  => 'goodnight'}, task.config)
      assert_equal "goodnight moon", task.process("moon")

      # a more complex test
      task.enq("moon")
      app.run

      assert_equal ["goodnight moon"], app.results(task)
      assert_audit_equal ExpAudit[[nil, "moon"], [task, "goodnight moon"]], app._results(task)[0]
    end
  end

Run the tests:

  % rap test

Run the task:

  % tap run -- goodnight moon
    I[23:22:19]          goodnight moon

Run the task, setting the 'message' configuration:

  % tap run -- goodnight moon --message hello
    I[23:22:46]              hello moon

Run multiple tasks, or in this case the same task twice:

  % tap run -- goodnight moon -- goodnight opus
    I[23:23:06]          goodnight moon
    I[23:23:06]          goodnight opus

Ok, good enough.  Lets share it.  Print the current gemspec manifest:

  % rap print_manifest
  true  README
        Rakefile
        lib/goodnight.rb
        sample.gemspec
        tap.yml
        test/goodnight_test.rb
  true  test/tap_test_helper.rb
  true  test/tap_test_suite.rb
  
As you can see, some files are included and some are not.  Open up sample.gemspec and fix the manifest (all you really need is tap.yml and the lib file):

  [sample.gemspec]
  Gem::Specification.new do |s|
    s.name = "sample"
    s.version = "0.0.1"
    s.platform = Gem::Platform::RUBY
    s.summary = "sample"
    s.require_path = "lib"
    s.add_dependency("tap", "~> 0.10.8")
    s.files = %W{
      lib/goodnight.rb
      tap.yml
    }
  end

Now package the gem, and install it (gem may require sudo):

  % rap gem
  % gem install pkg/sample-0.0.1.gem
  
Now you can say goodnight anywhere, using tap or rap:

  % cd ~/Desktop
  % tap run -- goodnight moon
  goodnight moon
  % rap goodnight opus
  goodnight opus

And that is that.

==== References

The basic syntax of a declaration is:

  # == A task declaration
  # name::           the name of the task, either alone or as the
  #                  key of a {key => dependencies} hash
  # dependencies::   an array of task names (optional)
  # arg_names::      an array of argument names (optional)
  # configurations:: a hash of {key => default} pairs (optional)

  task({name => [dependencies...]}, arg_names..., {configurations}) do |task, args|
    # arguments are available through args:
    args.arg_name
    
    # configurations are available through task
    task.key
  end
  
  # == A namespace declaration
  namespace(name) { task ... }
  
  # == Simple documentation 
  desc "description"
  task ...
  
  # == Extended documentation
  
  # ::desc description
  # Extended documentation may span multiple lines, and 
  # supports
  #
  #   code indentation
  #   like this.
  #
  # Lines are justified and wrapped on the command line.
  task ...

To make an imperative workflow you can either hard-code joins within the Tapfile, or specify the joins from the command line.  This example shows both:

  [Tapfile]
  extend Tap::Declarations
  
  # hard coded
  a = task(:a) { print 'a' }
  b = task(:b) { print 'b' }
  c = task(:c) { puts 'c' }
  a.sequence(b, c)
  
  # soft coded
  task(:x) { print 'x' }
  task(:y) { print 'y' }
  task(:z) { puts 'z' }
  
On the command line:

  % rap a
  abc
  % rap x --: y --: z
  xyz
  % rap x -- y -- z --0:1:2
  xyz
  
In the example, the two styles for soft-coding a workflow are used to illustrate a basic feature of rap syntax; individual tasks are separated by double-dash delimiters, and modifications to those delimiters specify a workflow.  In the modified delimiters, numbers indicate which tasks participate in a join while punctuation indicates a join type.  A variety of joins are supported:

  delimiter  function         syntax                 example        meaning 
  --         delimits tasks                          a -- b -- c    enques/configures tasks a, b, c
  --:        sequence         source:target          --0:1:2        sequence a, b, c
  --[]       fork             source[targets...]     --0[1,2]       fork a to (b,c)
  --{}       merge            target[sources...]     --2{0,1}       merge (a,b) to c
  --()       sync_merge       target[sources...]     --2(0,1)       synchronize merge (a,b) to c
  --*        dependency                              --* a          enques/configures the dependency a
  
Hard-coded workflows may be re-used on the command line in a soft workflow, it's all about the task.

  % rap c --: x --: y --: z --: a
  abc
  xyz
  abc

==== Rake v Rap vs Tap

In rap, pains were taken to make Tap +task+ behave like Rake +task+.  As in Rake, the instances produced by Tap +task+ are singletons and they can be extended with additional actions, dependencies, and configurations.  However, these features are rap-specific... the general class  This approach makes tasks less exotic... in Tap they're plain old classes, which facilitates testing, re-use, and allows for inheritance.
