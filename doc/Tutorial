= Tap (Task Application)

Tap is a framework for creating configurable, distributable tasks and workflows.  Although scalable for complex workflows, at it simplest tap works as a supercharged rake.  Using the rap executable, you can declare and run tasks using a syntax almost identical to rake, but with added support for configurations and documentation.  

== Quickstart

If you've used rake, tap will be easy to pick up.  To get started, make a Tapfile with a simple task declaration:

  [Tapfile]
    
  # ::desc your basic goodnight moon task
  # Says goodnight with a configurable message.
  Tap.task(:goodnight, :obj, :message => 'goodnight') do |task, args|
    puts "#{task.message} #{args.obj}\n"
  end
  
Now from the command line:

  % rap goodnight moon
  goodnight moon
  
  % rap goodnight world --message hello
  hello world
  
  % rap goodnight --help
  Goodnight -- your basic goodnight moon task
  --------------------------------------------------------------------------------
    Says goodnight with a configurable message.
  --------------------------------------------------------------------------------
  usage: tap run -- goodnight obj

  configurations:
          --message MESSAGE

  options:
      -h, --help                       Print this help
          --name NAME                  Specify a name
          --use FILE                   Loads inputs from file
  
Just like that you have a command-line application with inputs, configuration, and documentation.  

The declaration syntax is obviously similar to rake; configurations are new, but the task-block style is the same, as are inputs.  Other rake constructs are available.  Here is a similar goodnight task using dependencies, rake-style.

  [Tapfile]
  
  # make the declarations available everywhere
  # (normally they're accessed via Tap, as above)
  extend Tap::Declarations
  
  namespace :example do
    task(:say, :message) do |task, args|
      print(args.message || 'goodnight')
    end
    
    desc "your basic goodnight moon task"
    task({:goodnight => :say}, :obj) do |task, args|
      puts " #{args.obj}\n"
    end
  end

And now from the command line: 

  % rap goodnight moon
  goodnight moon
  
  % rap goodnight world --* say hello
  hello world

Unlike rake, rap inputs are written out individually and tasks are delimited by a modified double-dash (in this case --*, more on this later).  Aside from that, you can see rap is basically a supercharged rake.  Furthermore, rap runs rake.  Directly substitute rap for rake on the command line and your tasks should run as normal.

However, supercharging rake isn't the point of Tap.  Declarations bridge the gap between rake and tap, but tap itself is a more general framework.  To get at the other features like imperative workflows, testing, and distribution, we have to go beyond rap and take a look at what declarations do.

Spoiler: declarations make subclasses of Tap::Task. 

== Beyond Rap

Going back to the first example, lets take a look at how a declaration maps to a class definition:

  [Tapfile]
  
  # ::desc your basic goodnight moon task
  # Says goodnight with a configurable message.
  Tap.task(:goodnight, :obj, :message => 'goodnight') do
    puts "#{task.message} #{args.obj}\n"
  end
  
Here is a corresponding class definition:

  [Tapfile]
  
  # Goodnight::manifest your basic goodnight moon task
  # Says goodnight with a configurable message.
  class Goodnight < Tap::Task
    config :message, 'goodnight'

    def process(obj)
      "#{message} #{obj}"
    end
  end

Simple enough.  The name corresponds to the class, configurations (and dependencies, although they aren't show) are written out individually, and the block corresponds to process.  There are a few subtle differences, however, especially relating to process... but for the moment lets gloss over them and see how Goodnight works.

  Goodnight.configurations.to_hash         # => {:message => 'goodnight'}
  
  goodnight = Goodnight.new
  goodnight.message                        # => 'goodnight'
  goodnight.process('moon')                # => 'goodnight moon'
  
  hello = Goodnight.new(:message => 'hello')
  hello.message                            # => 'hello'
  hello.process('world')                   # => 'hello world'

Totally straightforward.  Goodnight stores the default configurations, each instance has accessors to the configurations, and the defaults may be overridden.  Process, as you would expect, is an ordinary method.

When it comes time to make a workflow, instances may be joined using a variety of methods ({sequence}[link:classes/Tap/Support/Joins/Sequence.html], {fork}[link:classes/Tap/Support/Joins/Fork.html], {switch}[link:classes/Tap/Support/Joins/Switch.html], {merge}[link:classes/Tap/Support/Joins/Merge.html], and {sync_merge}[link:classes/Tap/Support/Joins/SyncMerge.html] are supported by default).  To run a workflow, use execute.  The results of one task will be passed as the inputs of the next task and the final results collected by the underlying Tap::App.

  hello.sequence(goodnight)
  hello.execute('world')

  app = Tap::App.instance
  app.results(goodnight)                   # => ["goodnight hello world"]

If you think about what's going on the result makes sense.  The hello task modifies 'world' to make 'hello world' and that becomes the input to the goodnight task.  Tracking logic through two tasks isn't tough, but for many tasks it can be complex.  To help out, all workflows are audited.

  audit = app._results(goodnight)[0]
  audit._current                           # => "goodnight hello world"
  
  "\n#{audit._to_s}"
  # => %Q{
  # o-[] "world"
  # o-[goodnight] "hello world"
  # o-[goodnight] "goodnight hello world"
  # }
  
Now the workflow is clear.  The same workflow may be built from the command line using --:, the sequence delimiter:

  % rap goodnight world --message hello --: goodnight --+ dump
  # audit:
  # o-[] "world"
  # o-[goodnight] "hello world"
  # o-[goodnight] "goodnight hello world"
  # 
  # date: 2008-10-09 11:21:08
  --- 
  goodnight (2724600): 
  - goodnight hello world

Task declarations cannot pass inputs like this; they're second-class citizens for imperative workflows.  What's more, declarations can't do all the things possible in a class definition.  Class definitions, for example, allow variable inputs and inputs with defaults, configurations can be documented, and they support validation/transformation blocks.  A set of standard blocks are available through +c+, an alias for the Tap::Support::Validation module.

  [Tapfile]
  
  # Goodnight::manifest a fancy goodnight moon task
  # Says goodnight with a configurable message.
  class Goodnight < Tap::Task
    config :message, 'goodnight'           # a goodnight message
    config :reverse, false, &c.switch      # reverses the message
    config :n, 1, &c.integer               # repeats message n times
    
    def process(*objects)
      print "#{reverse == true ? message.reverse : message} " * n
      puts objects.join(', ')
      puts
    end
  end

Now from the command line:
  
  % rap goodnight moon
  goodnight moon
  
  % rap goodnight moon mittens "little toy boat"
  goodnight moon, mittens, little toy boat
  
  % rap goodnight world --message hello --reverse --n 3 
  olleh olleh olleh world
  
  % rap goodnight --help
  Goodnight -- a fancy goodnight moon task
  --------------------------------------------------------------------------------
    Says goodnight with a configurable message.
  --------------------------------------------------------------------------------
  usage: tap run -- goodnight OBJECTS...

  configurations:
          --message MESSAGE            a goodnight message
          --[no-]reverse               reverses the message
          --n N                        repeats message n times

  options:
      -h, --help                       Print this help
          --name NAME                  Specify a name
          --use FILE                   Loads inputs from file

By the outputs you can see the command line configurations are transformed into the proper objects by the time process gets called.  In addition, take a quick look at the documentation.  Configurations now have documentation and reverse is a switch!  The rich mapping of a class declaration to the command line allows tasks to act as an script interface, not unlike {OptionParser}[http://www.ruby-doc.org/stdlib/libdoc/optparse/rdoc/classes/OptionParser.html] (surprise, tap uses OptionParser).  

For example this is a stand-alone goodnight script:

  [goodnight]
  
  #!/usr/bin/env ruby
  
  require 'rubygems'
  require 'tap'

  # Goodnight::manifest a goodnight moon script
  # Says goodnight with a configurable message.
  class Goodnight < Tap::Task
    config :message, 'goodnight'

    def process(obj)
      puts "#{message} #{obj}\n"
    end
  end

  instance, args = Goodnight.parse!(ARGV)
  instance.execute(*args)
  
Now, from the command line:

  % ./goodnight moon
  goodnight moon
  
  % ./goodnight --help
  ...
  
The use of tasks on the command line does not involve magic.  Tasks are normal, predictable objects which the rap (and tap) executable makes available in a particular context.  Beyond rap, task classes may be subclassed, tested, and distributed as usual.

== Tap

Beyond rap is tap.  The tap executable is more verbose than rap for running tasks, but it is more capable, scalable, and logically pure.  The easiest way to get a feel for tap is to see it in action.

Tap comes with a number of commands but we'll focus on generate to make, test, and package a task library.  Begin by creating a tap directory structure and a task:

  % tap generate root sample
  % cd sample
  % tap generate task goodnight

Take a look at the task files an you find something like this:

  [lib/goodnight.rb]
  
  # Goodnight::manifest <replace with manifest summary>
  # <replace with command line description>

  # Goodnight Documentation
  class Goodnight < Tap::Task

    # <config file documentation>
    config :message, 'goodnight'           # a sample config
  
    def process(name)
      log message, name
      "#{message} #{name}"
    end
  end 

  [test/goodnight_test.rb]
  
  require File.join(File.dirname(__FILE__), 'tap_test_helper.rb') 
  require 'goodnight'

  class GoodnightTest < Test::Unit::TestCase
    acts_as_tap_test 

    def test_goodnight
      task = Goodnight.new :message => "goodnight"

      # a simple test
      assert_equal({:message  => 'goodnight'}, task.config)
      assert_equal "goodnight moon", task.process("moon")

      # a more complex test
      task.enq("moon")
      app.run

      assert_equal ["goodnight moon"], app.results(task)
      assert_audit_equal ExpAudit[[nil, "moon"], [task, "goodnight moon"]], app._results(task)[0]
    end
  end

Run the test:

  % rap test

Run the task:

  % tap run -- goodnight moon
    I[23:22:19]          goodnight moon

Ok, good enough.  Lets share it.  Print the current gemspec manifest:

  % rap print_manifest
  true  README
        Rakefile
        lib/goodnight.rb
        sample.gemspec
        tap.yml
        test/goodnight_test.rb
  true  test/tap_test_helper.rb
  true  test/tap_test_suite.rb
  
As you can see, this needs an update.  Open up sample.gemspec and fix the manifest... all you really need is tap.yml and the task file.

  [sample.gemspec]
  
  Gem::Specification.new do |s|
    s.name = "sample"
    s.version = "0.0.1"
    s.platform = Gem::Platform::RUBY
    s.summary = "sample"
    s.require_path = "lib"
    s.add_dependency("tap", "~> 0.10.8")
    s.files = %W{
      lib/goodnight.rb
      tap.yml
    }
  end

Now package the gem and install it (gem may require sudo):

  % rap gem
  % gem install pkg/sample-0.0.1.gem
  
Now you can say goodnight anywhere, using 'tap run' or rap:

  % cd ~/Desktop
  % tap run -- goodnight moon
  goodnight moon
  % rap goodnight opus
  goodnight opus

And that is that.

== Quick Reference

==== declarations

The basic syntax of a task declaration:

  # == A task declaration
  # name::           the name of the task, either alone or as the
  #                  key of a {key => dependencies} hash
  # dependencies::   an array of task names (optional)
  # arg_names::      an array of argument names (optional)
  # configurations:: a hash of {key => default} pairs (optional)

  task({name => [dependencies...]}, arg_names..., {configurations}) do |task, args|
    # arguments are available through args:
    args.arg_name
    
    # configurations are available through task
    task.key
  end
  
  # == A namespace declaration
  namespace(name) { task ... }
  
  # == Simple documentation 
  desc "description"
  task ...
  
  # == Extended documentation
  
  # ::desc description
  # Extended documentation may span multiple lines, and 
  # supports
  #
  #   code indentation
  #   like this.
  #
  # Lines are justified and wrapped on the command line.
  task ...

==== workflows

The basic syntax for an imperative workflow uses double-dash delimiters to separate individual tasks, and modified delimiters to specify joins for the tasks:

  % rap x
  % rap x --: y --: z
  % rap x -- y -- z --0:1:2
  
In the modified delimiters, numbers indicate which tasks participate in a join while punctuation indicates a join type.  In the second example, the numbers are implicitly added for the preceding and following task.  A variety of joins are supported:

  delimiter  function         syntax                 example        meaning 
  --         delimits tasks                          a -- b -- c    enques/configures tasks a, b, c
  --:        sequence         source:target          --0:1:2        sequence a, b, c
  --[]       fork             source[targets...]     --0[1,2]       fork a to (b,c)
  --{}       merge            target{sources...}     --2{0,1}       merge (a,b) to c
  --()       sync_merge       target(sources...)     --2(0,1)       synchronize merge (a,b) to c
  --*        dependency                              --* a          enques/configures the dependency instance for a

==== rake v rap v tap

In rap, pains were taken to make Tap task behave like Rake task.  As in Rake, the instances produced by Tap task are singletons and they can be extended with additional actions, dependencies, and configurations.  What's more, they're insular.  The inputs from one task are not passed to the next task in a workflow.  Lastly, like rake, declaration tasks only run once.  However, these features are rap-specific... in general a single task may be run multiple times, for instance in a looping workflow.  The major exception are instances used in a dependency-based workflow; these tasks only execute once.

A few syntactical differences between rake and rap must to be noted, as they can cause errors if you try to migrate rake tasks to tap.  Tap declarations:

* do not support :needs as a way to specify dependencies
* handle namespace lookups different is some cases

This will declare a needs configuration with the default value :another, not a task which depends on another:

  Tap.task :name, :needs => :another

Within a namespace, task will look for a literal match to the dependency first.  If it doesn't find one, it will declare it within the namespace.  Tasks obviously are always nested.  Hence, in this example the nested task depends on the non-nested task.  

  task :outer { print 'non-nested' }
  namespace :nest do
    task :inner => :outer { puts 'was executed' }
    task :outer { print 'nested' }
  end
  
By contrast, rake always uses a match within a namespace first.  Hence if you run these tasks by rap and rake, you get different results:

  % rap nest/inner
  non-nested was executed
  % rake nest:inner
  nested was executed
