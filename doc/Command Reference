= Command Reference

The tap command is the gateway for the execution of sub-commands.  To get help for tap, type:

  % tap --help
  
The tap command sets up the execution environment from 'tap.yml', if it exists, and passes control to the specified sub-command.  Sub-command help can be obtained using:

  % tap [sub-command] --help

=== tap run

Run configures, enqueues, and executes tasks.  Run has a rich syntax allowing the specification of any number of tasks with configurations and inputs, but simplifies under most circumstances.  Several examples illustrate the key points:

  % tap run sample/task 
  % tap run -- sample/task --key=value input_one -- another/task input_two
  
The second statement specifies two tasks with inputs, and specifies a configuration for sample/task.  As can be seen, run separates tasks using a double-dash, the standard option break.  Options for run itself can be specified before the first option break.

  % tap run --debug -- sample/task --key=value
  
Here run receives the '--debug' option and sample/task receives the '--key=value' option'.  <em>NOTE</em> it's always a good idea to include the first option break to formally signify when configuration of run stops.  Otherwise you may be confused when the following commands both produce the help for run:

  % tap run --help
  % tap run sample/task --help

Inputs work the same way.  For example:

  % tap run -- sample/task --key=value one -- another/task two three
  
Specifies the following:

  t1 = app.task('sample/task', :key => 'value')
  t1.enq('one')
  
  t2 = app.task('another/task')
  t2.enq('two', 'three') 
  
Any number of tasks, configurations, and inputs may be specified in this way.  As a special note, rake tasks can be specified as well.  If the app cannot find a tap task by the specified name, rake is loaded (using the same loading  rules as the rake command) and run tries to find a corresponding rake task. ENV options can be specified in the rake statement.

  % tap run -- test KEY=value

==== YAML inputs

Non-string inputs can be provided through run.  If an input begins with "---\n" then it is loaded as YAML into an object before being passed to a task. The syntax can be a lot to type, but is very handy to have around.  The following enques 'sample/task' with a hash input, {'number' => 1}.  

On *nix, just hit enter to get the next line:

  % tap run -- sample/task '---
  > number: 1'

On Windows, you need to pull some tricks to get newlines into your argument. Cleverly use a caret to ignore the next line feed:

  % tap run -- sample/task '---^
  More?
  More? number: 1'
  
Notice that pressing enter _every other line_ is what actually puts the "\n" into the  parameter.  Keep using carets to enter more lines. The syntax on Windows isn't exactly pretty, but it works... with a caveat.  The latest execution script generated by rubygems (tap.bat) re-processes inputs to tap before executing the command for real.  I haven't found a workaround short of invoking tap from ruby itself:

  % ruby C:/ruby/bin/tap run -- sample/task '---^
  More?
  More? number: 1'

=== tap generate/destroy

Generate and destory launch generator scripts, the same as in Rails.  By default Tap provides generators for:

root:: the basic Tap directory structure
task:: a Tap:Task and test for the task
file_task:: a Tap::FileTask and test for the task
workflow:: a Tap::Workflow and test for the workflow
config:: a yaml config file for the specified task 
command:: a new subcommand
generator:: a new generator

Some examples:

  % tap generate root .
  % tap generate task sample_task
  % tap generate config sample_task
  
  % tap destroy config sample_task
  % tap destroy task sample_task
  % tap destroy root .

=== tap console

Console opens an irb session with Tap loaded and configured using 'tap.yml'.  Console defines a variable 'app' referencing Tap::App.instance, for easy access.

  % tap console
  irb(main):001:0> app.log(:hello)
    I[17:18:53]              hello
  => true
  irb(main):002:0>
 
For actively testing your code, remember that many of your files will be loaded using Dependencies (from {ActiveSupport}[http://rubyforge.org/projects/activesupport/]).  You can modify your code, clear the  dependencies, and observe the changes within a single session.  The command is:

  irb(main):003:0> app.reload
  # => [... an array of unloaded constants ...]
