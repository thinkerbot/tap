#!/usr/bin/env ruby
# usage: tap [workflow...] [--- tapfile]
#
# examples:
#   tap load 'goodnight moon' --: dump   # a simple workflow
#   tap prompt                           # open a prompt
#
# help:
#   tap --help                           # prints this help
#

require 'tap'
require 'tap/parser'

if ENV['TAP_DEBUG'] == 'true'
  $DEBUG = true 
end

if ARGV == ['--help']
  puts Lazydoc.usage(__FILE__)
  puts "\nversion #{Tap::VERSION} -- #{Tap::WEBSITE}"
  exit(0)
end

begin
  options = {
    :gems       => ENV['TAP_GEMS'] || ['.'],
    :auto_path  => ENV['TAP_AUTO'] || ['.'],
    :env_path   => ENV['TAPENV'] || ['tapenv'],
    :taprc_path => ENV['TAPRC'] || ['~/.taprc']
  }
  
  app = Tap.setup(options)
  parser = Tap::Parser.new
  
  Dir.glob('[Tt]apfile{,.rb}').each do |tapfile|
    load tapfile
  end
  
  loop do
    break if ARGV.empty?
    parser.parse!(ARGV)
    parser.build_to(app)
  
    break if ARGV.empty?
    psr = ConfigParser.new(app.config, 
      :option_break => Tap::Parser::BREAK, 
      :keep_break => true, 
      :clear_config => false, 
      :add_defaults => false
    )
    psr.add(Tap::App.configurations)
    psr.scan(ARGV) do |file|
      app.call('sig' => 'load', 'args' => [file])
    end
  end
  
  # Traps interrupt the normal flow of the program and so I assume thread safety
  # is an issue (ex if the INT occurs during an enque and a signal specifies
  # another enque). A safer way to go is to enque the prompt... when the prompt
  # is executed the app won't be be doing anything else so thread safety
  # shouldn't be an issue.
  Signal.trap('INT') do
    puts
    puts "Interrupt!  Signals from an interruption are not thread-safe."
  
    require 'tap/tasks/prompt'
    prompt = Tap::Tasks::Prompt.new({:prompt => '~/'}, app)
    call_prompt = true
    3.times do
      print "Wait for thread-safe break? (y/n): "
    
      case gets.strip
      when /^y(es)?$/i
        puts "waiting for break..."
        app.pq(prompt, [])
        call_prompt = false
        break
      
      when /^no?$/i
        break
      end
    end
  
    if call_prompt
      prompt.call([])
    end
  end

  app.run
rescue(SystemExit)
  raise
rescue(Exception)
  raise if $DEBUG
  $stderr.puts "#{$!.message} (#{$!.class})"
  exit(1)
end

exit(0)