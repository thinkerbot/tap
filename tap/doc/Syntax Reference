= Syntax Reference

Tap uses several domain-specific languages to declare tasks and workflows.
This is a reference for:

* class definitions
* workflows

== Task Classes

This is a verbose prototype for Tap::Task subclasses:

  # <ClassName>::manifest summary description
  #
  # Extended documentation...
  #
  class ClassName < Tap::Task
    
    # Sets up a configuration and makes the 'key' and 'key=' accessors.
    # 
    # This documentation appears in static config files, and in RDoc.
    #
    config :key, 'default value' do |value|  # config summary
      "the config is set to the return value"
    end 
    
    # Subclasses BaseClass with the specified configs, using the block
    # to override process.
    #
    # Also creates the methods 'name', 'name_config', 'name_config='.  
    # The first will access an instance-specific instance of the 
    # subclass, the other two are accessors for the instance configs.
    # 
    # Primarily used in conjunction with workflow.
    #
    define :name, <BaseClass>, {<configs>} do |*args|
      # this is the process block
    end
    
    # Causes each instance to depend on DependencyClass.instance.
    #
    # Also defines a reader 'name' which will access the results
    # of the dependency.
    depends_on :name, <DependencyClass>
    
    def process(*args)
      # the method defining what this task does 
    end
    
    protected

    def workflow
      # a hook to setup joins between various tasks used
      # by the current instance.  workflow is called
      # during initialize
    end

    def before_execute() 
      # a hook to execute code before process
      # (only works in workflows)
    end
  
    def after_execute()
      # a hook to execute code after process
      # (only works in workflows)
    end

    def on_execute_error(err)
      # a hook to handle errors during process
      # (only works in workflows)
    end
  end

== Workflows

The tap workflow syntax is designed to specify an arbitrary number of tasks,
inputs, configurations, and joins.  The syntax works both as text and as YAML;
'tap run' uses it to specify which tasks to execute.  Basically, the syntax
uses double-dash delimiters to separate task vectors and modified delimiters
to specify joins for the tasks.  

These both specify three tasks (x,y,z) joined in a sequence:

  % tap run -- x --: y --: z
  % tap run -- x -- y -- z --0:1:2
  
The modified delimiters use numbers to indicate which tasks participate in a
join and punctuation to indicate the join type.  In the first example, the
numbers are implicitly added for the preceding and following task.  A variety
of joins are supported:

  delimiter  function         syntax                 example        meaning 
  --         delimiter                               a -- b -- c    enques/configures tasks a, b, c
  --*        dependency                              --* a          enques dependency instance
  --+        round                                   --+ a --++ b   enques a to round one, b to round two
  --+[]      round shorthand  +round[targets]        --+2[0,1]      enques (a,b) to round two
  
  --:        sequence         source:target          --0:1:2        sequence a, b, c
  --[]       fork             source[targets...]     --0[1,2]       fork a to (b,c)
  --{}       merge            target{sources...}     --2{0,1}       merge (a,b) to c
  --()       sync_merge       target(sources...)     --2(0,1)       synchronize merge (a,b) to c

Inputs may be specified between delimiters:

  % tap run -- x alpha beta --: y gamma --: z delta

As may be configurations, in a variety of formats:

  % tap run -- x alpha beta -k --: y gamma --key value --: z delta --key=value
  
These are the corresponding task vectors:

  ['x', 'alpha', 'beta', '-k']
  ['y', 'gamma', '--key', 'value']
  ['z', 'delta', '--key=value']

This is how it would look as YAML:

  - - x
    - alpha
    - beta
    - -k
  - - y
    - gamma
    - key: value
  - - z
    - delta
    - --key=value
  - 0:1:2

The task vectors are converted into a task and an argument vector by first
looking up a task class and then calling TaskClass.parse.  The parse method
returns a configured instance of the task and an argv to be executed by the
task.  Once the task are instantiated, instances are joined and enqued to
Tap::App for execution (see Tap::Support::Schema#build).

==== Class Lookup

Tap looks up classes via Tap::Env.  Tap can find tasks from multiple
environments; by adding in environments for gems, Tap can find tasks
within a gem.

During lookup, classes are treated like filepaths which match from the
basename up:

  class             lookup              matched by
  Sample::Task      sample/task         task, sample/task
  A::Nested::Task   a/nested/task       task, nested/task, a/nested/task

In the event of a name conflict, the path of the environment may also be
specified.  It seems like this could get confusing, but the tap executable
produces manifests that specify the minimal path required to uniquely
identify a class.  Fragments of the minimized paths will be resolved in order
from top to bottom within the specified environment.  For example: 

  % tap run -T
  one:
    sample/task      # some sample task
    another/task     # another task
  two:
    sample/task      # a conflicting sample task

Runs the 'one' sample/task:

  % tap run -- sample/task
  % tap run -- one:sample/task

Runs the 'two' sample/task:

  % tap run -- two:sample/task

Runs the 'one' sample/task:

  % tap run -- task

Runs the 'two' sample/task:

  % tap run -- two:task

Runs another/task:

  % tap run -- another/task
  % tap run -- one:another/task

Notice that the full minimized path ('another/task') is required because simply
using 'task' will be matched to sample/task.  The order of tasks is obviously
not alphabetical -- rather it corresponds to the order in which Tap::Env
discovers the tasks.

==== Dependencies (--*)

Normally each task vector specifies a new instance of a task.  This specifies
three instance of the 'a' task.

  % tap run -- a -- a -- a
  
When you want to specify a 'singleton' instance of a task, the instance
specified by TaskClass.instance, use the dependency delimiter '--*'.  

  % tap run --* a
  
The dependency instance will be configured and enqued with the arguments.
Dependency instances will be executed first, even if they are specified at the
end of a workflow, they cannot participate in workflows, and any single
dependency may only be specified once in a workflow.  These are equivalent:

  % tap run --* a -- b -- c
  % tap run b -- c --* a

While these raise errors:

  % tap run --* a --* a
  % tap run --* a --: b

==== Rounds (--+)

The workflow syntax allows multiple execution rounds to be specified  All tasks
in a round are run to completion before the next round begins.  Rounds are
specified by adding '+' characters after the double-dash break.

  % tap run -- round_one_task --+ round_two_task

Tasks may be added to rounds in any order and may use the shorthand for multiple
tasks.  These are equivalents:

  % tap run -- a --+ b --+ c --++ d
  % tap run --+ b --++ d -- a --+ c
  % tap run -- a -- b -- c -- d --+1[1,2] --+2[3]

Rounds are particularly useful for dump tasks; add a dump task as a final round
to capture all results from previous rounds:

  % tap run -- task -- task --+ dump

