= Workflow Basics

Tap uses a custom syntax for specifying workflows from the command line. The
syntax is simple: arguments specify a workflow object class, then any inputs
and/or options.

  % tap dump 'goodnight moon'
  goodnight moon
  
  % tap dump --help
  Tap::Tasks::Dump -- the default dump task
  ...

=== Sequence

Objects can be linked into sequences using a -: break.

  % tap load 'goodnight moon' -: dump
  goodnight moon
  
=== Canon

The more canonical way of specifying a sequence builds each workflow object
individually. A single dash separates workflow objects:

  % tap load 'goodnight moon' - dump - join 0 1
  goodnight moon

A double-dash will build _and enque_ the next object:

  % tap dump goodnight -- dump moon
  goodnight
  moon

The workflow syntax reserves dash and all dash-nonword pairs as breaks. To
enter a reserved break, use the escape begin (-.) and end (.-):

  % tap dump begin -. - -- --- -: -/ --/ .- end
  begin - -- --- -: -/ --/ end

Not all possible breaks are used, but reserving them all makes for a simple
rule.

=== Fork

Pass a single output to multiple objects:

  % tap load 'goodnight moon' - dump - dump - join 0 1,2
  goodnight moon
  goodnight moon
  
=== Merge

Direct multiple outputs to a single object. Note that outputs are passed as
they become ready, without synchronization.

  % tap load goodnight - load moon - dump - join 0,1 2
  goodnight
  moon

=== Synchronized Merge

Similar to a merge, but the outputs are collected into an array before being
passed. The printout is: ['goodnight', 'moon'].to_s

  % tap load goodnight - load moon - dump - sync 0,1 2
  goodnightmoon

=== Gate Merge

Same idea as a synchronized merge, but fires after a certain number of outputs
have been collected:

  % tap load a - load b - load c - dump - gate 0,1,2 3 --limit 2
  ab
  c

=== Variations

Joins can iterate or arrayify outputs before passing them to join targets. These
options are useful for aligning the input/output signatures of workflow objects
across a join.  For example, using the yaml loading task from tap-tasks:

  % tap load/yaml "[1, 2, 3]" - dump - join 0 1
  123
  
  % tap load/yaml "[1, 2, 3]" - dump - join 0 1 --iterate
  1
  2
  3

Sequence joins can specify flags and a join class in a shorthand like
'-:flags.class'. For example, these are equivalent workflows:

  % tap load/yaml "[1, 2, 3]" - dump - dump - join 0 1 --iterate - gate 1 2
  1
  2
  3
  123
  
  % tap load/yaml "[1, 2, 3]" -:i dump -:.gate dump
  1
  2
  3
  123

=== Signals

Workflows can quickly become cumbersome to write in the single-line syntax.
Internally workflows are parsed into signals that build and enque workflow
objects.  These signals can be specified manually on the command line:

  % tap -/set 0 load -/set 1 dump -/build join 0 1 -/enq 0 'goodnight moon'
  goodnight moon

Invoked from a prompt:

  % tap prompt
  /set 0 load
  /set 1 dump
  /build join 0 1
  /enq 0 'goodnight moon'
  /run
  goodnight moon
  
Or specified in a taprc file:

  [taprc]
  set 0 load
  set 1 dump
  build join 0 1
  enq 0 'goodnight moon'

  % tap --- taprc
  goodnight moon

Signals are used as the basis for controlling apps and objects. As a final
note, signals on the command line can be enqued using '-/' or executed
immediately with '--/'.

  % tap - dump -/enq 0 enque --/enq 0 execute
  execute
  enque

Both are handy to have around.
