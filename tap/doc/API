= Application Programming Interfaces

Note these are all currently provisional.  The required methods are listed in the table with the parameter signature.

== Node

call(*inputs)::  Any return
dependencies:: An array of Dependencies
join:: A Join or nil

== Join

call(result):: Any return

== Application Middleware

Middleware.new(stack):: An instance of middleware
call(node, inputs=[]):: Any return
stack():: The input stack

The middleware API is essentially the same as for Rack.

== Identification/Documentation

Resources are identified by a constant attribute corresponding to their baseclass and filename, so for instance this registers the Sample task:

  [sample.rb]
  # ::task summary
  # description
  class Sample < Tap::Task
  end
  
Joins are similarly identified, and in other modules so are generators and controllers.

Join:: ::join
Generator:: ::generator
Controller:: ::controller

In each case the summary and description are available like:

  Sample::desc.summary         # => "summary"
  Sample::desc.to_s            # => "description"

== Creation/Access

=== instance

Many base classes have a 'global' instance associated with them.  These instances are only for convenience and have no special meaning attributed to them; the can be used or ignored as needed for a specific application.

Env.instance():: Useful for passing environment information from the tap
                 executable to commands.  Env.instance is set by
                 Tap::Exe.setup.
App.instance():: Tasks, which require an app, are initialized to this
                 instance unless otherwise specified.
TaskClass.instance(app):: 
                 Initializes or returns an app-specific instance of the 
                 TaskClass.  Mainly used for class-level dependencies.  
                 Instances are cached in app.cache.
                          
=== intern

Many Tap objects differ only by a block.  Intern wrangles a block into objects of a specific type:

Node.intern:: |*inputs|
Task.intern(config={}, name=nil, app=App.instance):: |task, *inputs|
Join.intern(config={}, app=pp.instance):: |join, result|

=== parse/instantiate

Schema describe workflows as data using argument vectors and hashes.  Objects in the workflow like Tasks and Joins need to be instantiated these data structures and the parse/instantiate methods are provided to do so.  Parse (and the related parse!) instantiates from an argv, while instantiate instantiates from an argh.  An app may be provided to either method; by default App.instance is used.

TaskClass.parse(argv=ARGV, app=App.instance):: 
                  Inputs an argv, like what comes from the command line, and
                  handles command line options. Parse can take a string; it
                  is converted to an argv using shellwords. Typically parse
                  converts the argv to an argh, which is internally sent to
                  instantiate. Returns a [task, args] array.
TaskClass.instantiate(argh, app=App.instance):: 
                  Inputs an argh, like what gets generated by a schema dump.
                  Returns a [task, args] array.
JoinClass.parse(argv=ARGV, app=App.instance):: 
                  Inputs an argv, returns a join instance. Typically the
                  argv is converted to an argh, and then internally sent to
                  instantiate.
JoinClass.instantiate(argh, app=App.instance):: 
                  Inputs an argh, returns a join instance.

The parse! method has the same behavior as parse, but destructively removes arguments from the input argv, as per convention.
