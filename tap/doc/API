= Application Programming Interface

(Note these are all currently provisional.)

== Tap::App

Applications require the following API for nodes, joins, and middleware.

==== Node

Note the signature for call can be modified as necessary.

  call(*inputs)    any return is allowed
  dependencies()   returns an array of dependency nodes
  joins()          returns an array of joins

==== Dependency

Same as a node, but call must be able to execute without inputs. For instance
signatures like call(), call(a=:default), or call(*inputs) are allowed, but
call(a, b, c) is not.

==== Join

  call(result)     any return is allowed

==== Middleware

  Middleware.new(stack)   returns an instance of middleware
  call(node, inputs=[])   any return is allowed
  stack()                 returns the original stack

Note the middleware API is essentially the same as for {Rack}[http://rack.rubyforge.org/].

== Tap::Schema

Schema describe workflows as data.  To build a workflow from a schema, workflow classes need to instantiate themselves using the schema data. The <tt>parse!</tt> and <tt>instantiate</tt> methods are provided to do so.  

  WorkflowClass.parse!(argv=ARGV, app=App.instance)
  WorkflowClass.instantiate(argh, app=App.instance)
  
As implied in by the inputs, <tt>parse!</tt> instantiates from an array, while <tt>instantiate</tt> instantiates from a hash.  If <tt>parse!</tt> receives a string, it must be able to convert it to an array (ex using Shellwords).

How the class actually performs the instantiation is up to the class but typically:

* <tt>parse!</tt> destructively parses argv
* <tt>parse!</tt> creates an argh and calls instantiate
* <tt>parse</tt> is implemented to non-destructively parse argv

==== Tap::Task (and subclasses)

Parse and instantate must return: [instance, args]

==== Tap::Join (and subclasses)

Parse and instantate must return: [inputs, outputs, instance]

== Tap::Env

Envs identify resources by a constant attribute using Tap::Env#constant_manifest.  For instance this identifies the Sample node:

  [sample.rb]
  
  # ::node summary
  # description
  class Sample < Tap::Node
  end

Here the constant name is inferred using the filepath.  A more formal declaration allows resources to be placed in files that are not named after the resource:

  [alt.rb]
  
  # Sample::node summary
  # description
  class Sample < Tap::Node
  end

Joins are similarly identified by <tt>::join</tt>.  Resources intended to be discovered by constant_manifest must map the attribute documentation to the class 'desc' method.  

  Sample::desc.summary         # => "summary"
  Sample::desc.to_s            # => "description"
  
The easiest way to do so is with a {lazy_attr}[link:lazydoc/classes/Lazydoc/Attributes.html].

  # ::resource
  class Resource
    lazy_attr :desc, 'resource'
  end
