= Application Programming Interfaces

Applications require the following methods for nodes, joins, and middleware.
Tap provides base classes that implement these APIs. Notably, all joins
satisfy the node API.

Objects satisfying the node, join, or middleware API are referred to as
workflow objects.

=== {Node}[link:classes/Tap/App/Node.html] ({Task}[link:classes/Tap/Task.html])

  call(input)                    # any return is allowed
  joins()                        # returns an enumerable of joins, or nil (optional)

The call method takes an object and returns an object. There are no formal
constraints for the input/output objects.

The optional joins method specifies an enumerable of joins (ie an object that
responds to each) to be called by an application when the node completes. Each
join is called in order. An empty array specifies the default application
joins should be called; nil specifies that no joins should be called. No joins
will be called when the joins method is left undefined.

=== {Join}[link:classes/Tap/Join.html]

  call(output)                   # any return is allowed

The call method receives the output of a node. The result of call is not used
(although it could be if a join is used as a node); call internally performs
the join actions.

=== {Middleware}[link:classes/Tap/Middleware.html]

  Middleware.new(stack, *args)   # returns an instance of middleware
  call(node, input)              # return is the node output
  stack()                        # returns the original stack

Middleware wraps the execution of nodes. Nodes and inputs are passed to the
middleware during execution; the middleware is responsible for calling the
node or passing it into the stack using the same call API. Joins, if defined,
are performed with the call output.

== {Application Interface}[link:classes/Tap/App/Api.html]

Tap defines an interface allowing applications to create and manage objects
using signals. The application interface is distinct from the workflow APIs,
although typically one will be implemented on top of the other. Objects
satisfying the application interface are referred to as application objects.

The application interface allows instantiation of a class from a hash and
serialization of an instance back into a hash. The hash is referred to as a
specification and must be serializable as {JSON}[http://json.org/] (meaning
the hash must consist of simple object types: numbers, strings, hashes, and
arrays).

The application interface consists of two methods, build and to_spec:

  class Example
    class << self
      # Build takes a specification and returns an instance of self.
      # The spec must be serializable as JSON.
      def build(spec={}, app=Tap::App.instance)
      end
    end
    
    # Takes no inputs and returns a specification that, when built,
    # returns an object like self.
    #
    #   obj.class.build(obj.to_spec)      # => returns an object like obj
    #
    # Users can determine for themselves what constitutes 'likeness'.
    def to_spec
    end
  end

The application interface reserves several additional methods that do not need
to be implemented but add functionality for specific, common use cases. If
they are present they must adhere to these specifications.

  # Optional methods #
  class Example
    class << self
      # Parse takes an argument vector (an array, usually from the command
      # line) and returns an instance of self.  If a block is given, parse
      # yields the instance and remaining args and returns block result.
      #
      # Parse should not modify argv.
      def parse(argv=ARGV, app=Tap::App.instance)
      end
      
      # Same as parse, but able to modify argv.
      def parse!(argv=ARGV, app=Tap::App.instance)
      end
    end
    
    # Takes a signal name and returns an object that responds to call; the
    # call method invokes the signal actions.
    def signal(sig)
    end
    
    # Returns a nested array of application objects associated with self.
    # The array should be structured like [refs, brefs], where refs are
    # references to objects that must be built BEFORE self and brefs are
    # back-references to objects that must be built AFTER self.
    #
    # For example, nodes must be built before joins.  As such, the associations
    # method for a node returns a brefs for each of its joins. Similarly, joins
    # must be built after nodes and hence the associations method for a join
    # returns refs to their input and output nodes:
    #
    #   node.associations       # => [nil, join]
    #   join.associations       # => [inputs + outputs, nil]
    #
    # Nil is a valid return for associations, indicating no associations.
    def associations
    end
  end

The parse methods are used for building objects from interfaces that provide
an array of inputs (ex the command line) rather a hash; without them objects
are effectively excluded from use within these interfaces.

Signals can be used to interact with specific objects from a user interface
much as signals can interact with an app. Objects without a signal method
cannot receive signals.

The associations method is used to order complex builds and is described in
more detail below.

=== Object References

Specifications often require references to other resources, as when a join
refers to input and output nodes. These references are normally specified as
variables that, unlike the resource itself, are easily serializable as JSON.
Apps manage variables via the +obj+ and +var+ methods.

As an example, consider the Sample class that references some other
application object:

  class Sample
    def initialize(object)
      @object = object
    end

    def to_spec
      {'key' => app.var(@object)}        # store a variable into the spec
    end

    def associations
      [[@object], nil]                   # establish a build order
    end
    
    class << self
      def build(spec={}, app=Tap::App.instance)
        object = app.obj(spec['key'])    # retrieve an object referenced by the spec
        new(object)
      end
    end
  end

Using this technique the spec will have a serializable variable representing
the object and the app will be able to properly serialize and rebuild the
instance and all its references. Applications use the associations array to
determine the correct build-order for the references.

Note that only references to objects implementing the application interface
should be stored this way.
