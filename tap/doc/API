= Application Programming Interface

Applications require the following methods for nodes, joins, and middleware.
Tap provides modules or base classes that implement these APIs and may be used
as the foundation for subclasses.

=== {Node}[link:classes/Tap/App/Node.html] ({Task}[link:classes/Tap/Task.html])

  call(*inputs)    # any return is allowed
  joins()          # returns an array of joins, or nil (optional)

The signature for call can be modified as necessary; any restrictions on the
signature simply define the arguments that must be passed to the node from the
command line or via a join.

The joins will be called when the node completes. If joins returns an empty
array then the default application joins are called instead. If joins is not
defined or returns nil then no joins will be called.

=== {Join}[link:classes/Tap/Join.html]

  call(result)     # any return is allowed

The call method receives the result of input nodes as they complete. The
result of call is not used; call must internally performing the join actions.

=== {Middleware}[link:classes/Tap/Middleware.html]

  Middleware.new(stack, *args)   # returns an instance of middleware
  call(node, inputs=[])          # any return is allowed
  stack()                        # returns the original stack

The middleware API is essentially the same as for
{Rack}[http://rack.rubyforge.org/]. Nodes enter middleware during execution;
the middleware is responsible for processing the node, or passing it into the
stack using the same call API.

== Application Interface

In addition to the APIs for individual workflow objects, Tap defines an
application API allowing objects to be created and modified from user
interfaces such as a web application or the command line. The application API
is distinct from the object APIs, although it is typical to implement the
application API in on top of an object API.

Tap::App::Api implements the application interface in a general way and is the
baseclass for Tap::Task, Tap::Join, and Tap::Middleware. The basic idea behind
the application interface is to allow instantiation of a class from a hash and
conversion of an instance into a hash. The hash is referred to as a
specification and must be serializable as {JSON}[http://json.org/].

This is a stub outlining the application interface:

  class Stub
    class << self
      # Build takes a specification hash and returns an instance of self.
      # The spec must be serializable as JSON.
      def build(spec={}, app=Tap::App.instance)
      end
    end
    
    # Takes no inputs and returns a specification hash that, when built,
    # returns an object like self.
    #
    #   obj.class.build(obj.to_spec)      # => returns an object like obj
    #
    # Users can determine for themselves what constitutes 'likeness'.
    def to_spec
    end
  end

The application API reserves several additional methods that do not need to be
implemented but add functionality for specific, common use cases. If they are
present they must adhere to these specifications.

  # Optional methods #
  class Stub
    class << self
      # Parse takes an argument vector (an array, usually from the command
      # line) and returns an instance of self.  Parse cannot modify argv.
      def parse(argv=ARGV, app=Tap::App.instance)
      end
      
      # Same as parse, but able to modify argv.
      def parse!(argv=ARGV, app=Tap::App.instance)
      end
    end
    
    # Takes a signal name and returns an object that responds to call; calling
    # call on the object invokes the signal actions.
    def signal(sig)
    end
    
    # Returns a nested array of workflow objects associated with self (ex 
    # input/output nodes for a join).  The array should be structured like
    # [refs, brefs], where refs are references to objects that must be built
    # BEFORE self and brefs are back-references to objects that must be built
    # AFTER self.
    #
    # For example, nodes must be built before joins.  As such, nodes return
    # brefs for each of the joins. Similarly, joins return refs to their input 
    # and output nodes:
    #
    #   node.associations       # => [nil, join]
    #   join.associations       # => [inputs + outputs, nil]
    #
    # Nil is also a valid return for associations, indicating no associations.
    def associations
    end
  end

The parse methods are used for building objects from interfaces that provide
an array of inputs (ex the command line) rather a hash; without them objects
are effectively excluded from use within these interfaces. Signals are used to
interact with objects from a user interface. Objects without a signal method
cannot receive signals. The associations method is used to order complex
builds and is described below.

=== Spec References

Specifications often require references to other resources, as when a join
refers to input and output nodes. These references are normally specified as
variables to ensure the specification is serializable as JSON. Apps are
constructed to do this easily via the +obj+ and +var+ methods:

  class Sample
    class << self
      def build(spec={}, app=Tap::App.instance)
        object = app.obj(spec['key'])    # lookup an object from the spec
        new(object)
      end
    end

    def initialize(object)
      @object = object
    end

    def to_spec
      {'key' => app.var(@object)}        # store a variable into the spec
    end

    def associations
      [[@object], nil]
    end
  end

Using this technique the spec always will have a serializable variable
representing the object and the app will be able to properly schematize and
rebuild the Sample instance and all its references. Apps use the associations
array to determine the correct build order for references. In the example the
@object reference must be built before the Sample instance, hence the
associations array returns a ref (rather than a bref) to @object.

Note that only application objects may be stored this way; non-application
objects must be serialized and deserialized by the build/to_spec methods
internally.

=== Resource Identifiers

Tap discovers application resources using resource identifiers (ie constant
attributes, see {Lazydoc}[http://tap.rubyforge.org/lazydoc]). Resources
identified in this way can be automatically loaded by the Tap::Env, and as a
result, specified directly from the command line. If no identifiers are
specified for a resource, the user is responsible for manually requiring the
resource.

As an example, this identifies the Sample constant as an 'example' resource.

  [lib/file.rb]
  
  # Sample::example summary
  class Sample
  end

A resource can be identified by zero or more identifiers. Typically all
identifiers will be put in the same file as the class, but this does not have
to be the case; applications automatically require all files that identify a
resource. The order in which the files are required is indeterminate and it is
up to the user to ensure consistency. For example:

  [a.rb]
  # Sample::a
  class Sample
  end
  
  [b.rb]
  require 'a'

  # Sample::b
  class Sample
  end

Here the require statement ensures a.rb is always required before b.rb. Note
that consistency is automatic when all identifiers are in the same file (and
thus only one file is required).

The constant name will be inferred from file path if no constant name is
specified. This is the most compact form for identifying a resource:

  [lib/sample.rb]
  
  # ::example summary
  class Sample
  end

In this case no constant name is specified, so 'Sample' is inferred from
'sample.rb'. Constant names are determined from the path using camelization.