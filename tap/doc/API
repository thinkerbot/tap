= Application Programming Interface

Applications require the following methods for nodes, joins, and middleware.
Tap provides modules or base classes that implement these APIs and may be used
as the foundation for subclasses.

=== {Node}[link:classes/Tap/App/Node.html] ({Task}[link:classes/Tap/Task.html])

  call(*inputs)    # any return is allowed
  joins()          # returns an array of joins, or nil (optional)

The signature for call can be modified as necessary; any restrictions on the
signature simply define the arguments that must be passed to the node from the
command line or via a join.

The joins will be called when the node completes. If joins returns an empty
array then the default application joins are called instead. If joins is not
defined or returns nil then no joins will be called.

=== {Join}[link:classes/Tap/Join.html]

  call(result)     # any return is allowed

The call method receives the result of input nodes as they complete. The
result of call is not used; call must internally performing the join actions.

=== {Middleware}[link:classes/Tap/Middleware.html]

  Middleware.new(stack, *args)   # returns an instance of middleware
  call(node, inputs=[])          # any return is allowed
  stack()                        # returns the original stack

The middleware API is essentially the same as for
{Rack}[http://rack.rubyforge.org/]. Nodes enter middleware during execution;
the middleware is responsible for processing the node, or passing it into the
stack using the same call API.

== Application Interface

In addition to the APIs for individual workflow objects, Tap defines an
application API allowing objects to be created and modified from user
interfaces such as the command line. The application API is distinct from the
object APIs, although it is typical to implement the application API in on top
of an object API.

Tap::App::Api implements the application interface in a general way and is the
baseclass for Tap::Task, Tap::Join, and Tap::Middleware. The basic idea behind
the application interface is to allow instantiation of a class from an array
(as from the command line) or a hash (as from HTTP request parameters). The
interface also allows instances to serialize as a {JSON}[http://json.org/]
hash. The hash is referred to as a specification.

This is a stub outlining the application interface:

  class Stub
    class << self
      
      # Parse takes an argument vector (an array, usually from the command
      # line) and returns an instance of self.  parse! is allowed to
      # destructively remove arguments from argv.
      def parse!(argv=ARGV, app=Tap::App.instance)
      end
      
      # Build takes a specification hash and returns an instance of self.
      # The spec must be serializable as JSON.
      def build(spec={}, app=Tap::App.instance)
      end
    end
    
    # Takes no inputs and returns a specification hash that, when built,
    # returns an object like self.
    #
    #   obj.class.build(obj.to_spec)      # => returns an object like obj
    #
    # Users can determine for themselves what constitutes 'likeness'.
    def to_spec
    end
    
    # Takes no inputs and returns a nested array of workflow objects 
    # associated with self (ex input/output nodes for a join).  The
    # array should be structured like [refs, brefs], where refs are
    # references to objects that must be built BEFORE self and brefs are
    # back-references to objects that must be built AFTER self.
    #
    # For example, nodes must be built before joins.  As such, nodes return
    # brefs for each of the joins and joins return refs to their input and
    # output nodes:
    #
    #   node.associations       # => [nil, join]
    #   join.associations       # => [inputs + outputs, nil]
    #
    # Nil is a valid return for associations, indicating no associations.
    def associations
    end
    
    # (optional)
    
    # Takes a signal name and returns an object that responds to call.
    # Signals are a generalized way to trigger some action on an object.
    # See Tap::Signals for more details.
    def signal(sig)
    end
  end

=== Spec References

Resource specifications often require references to other resources, as when a
join refers to input and output nodes. To satisfy the requirement that these
references are serializable as JSON, specify the references as string
variables and resolve them internally to other objects. Apps are constructed
to do this easily via the +obj+ and +var+ methods:

  class Sample
    class << self
      def build(spec={}, app=Tap::App.instance)
        object = app.get(spec['key'])    # lookup an object from the spec
        new(object)
      end
    end

    def initialize(object)
      @object = object
    end

    def to_spec
      {'key' => app.var(@object)}        # store a variable into the spec
    end

    def associations
      [[@object], nil]
    end
  end

The associations array allows apps to determine the correct build order for
references. In the example the @object reference must be built before the
Sample instance, hence the associations array returns a ref (rather than a
bref) to @object.

=== Resource Identifiers

Tap discovers application resources using resource identifiers (ie constant
attributes, see {Lazydoc}[http://tap.rubyforge.org/lazydoc]). Resources
identified in this way can be automatically loaded by the Tap::Env, and as a
result, specified directly from the command line. If no identifiers are
specified for a resource, the user is responsible for manually requiring the
resource.

As an example, this identifies the Sample constant as an 'example' resource.

  [lib/file.rb]
  
  # Sample::example summary
  class Sample
  end

A resource can be identified by zero or more identifiers. Typically all
identifiers will be put in the same file as the class, but this does not have
to be the case; applications automatically require all files that identify a
resource. The order in which the files are required is indeterminate and it is
up to the user to ensure consistency. For example:

  [a.rb]
  # Sample::a
  class Sample
  end
  
  [b.rb]
  require 'a'

  # Sample::b
  class Sample
  end

Here the require statement ensures a.rb is always required before b.rb. Note
that consistency is automatic when all identifiers are in the same file (and
thus only one file is required).

The constant name will be inferred from file path if no constant name is
specified. This is the most compact form for identifying a resource:

  [lib/sample.rb]
  
  # ::example summary
  class Sample
  end

In this case no constant name is specified, so 'Sample' is inferred from
'sample.rb'. Constant names are determined from the path using camelization.