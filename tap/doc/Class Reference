= Class Reference

This is a ground-up overview of the main classes and modules used by Tap,
specifically Tasks, Apps, and Envs.

== Tasks

==== Methods

http://tap.rubyforge.org/images/Method.png

Tasks are fundamentally just a method, simply a block of code.

==== Tap::Support::Executable

http://tap.rubyforge.org/images/Executable.png

Executable essentially wraps a method and adds support for dependencies, joins,
and auditing.  Executables are the nodes in a workflow.  Any Executable may be
joined to another Executable, enqued, and run by an App.  To wrap a method,
Executable extends an object and defines which method on the object is 'executable'.
Any method may be made executable, and so any method can participate in a workflow
(see Object#_method).

Tasks are constructed such that <tt>process</tt> is the executable method, hence
<tt>process</tt> is the standard method overridden in Task subclasses.

==== {Configurable}[http://tap.rubyforge.org/configurable/]

http://tap.rubyforge.org/images/Configurable.png

Tap uses the {Configurable}[http://tap.rubyforge.org/configurable/] module to
declare class configurations and make them available on the command line.
Configurations are essentially a shorthand to define attributes with a default
value.  For instance:
  
  class ConfigClass
    include Configurable

    config :key, 'value' do |input|
      input.upcase
    end
    
    def initialize
      initialize_config
    end
  end

Is basically the same as:

  class RegularClass
    attr_reader :key

    def key=(input)
      @key = input.upcase
    end

    def initialize
      self.key = 'value'
    end
  end

Configurations may be accessed through a hash-like config object, as you can
see here:

  c = ConfigClass.new
  c.key                       # => 'VALUE'

  c.config[:key] = 'new value'
  c.key                       # => 'NEW VALUE'

  c.key = 'another value'
  c.config[:key]              # => 'ANOTHER VALUE'

This setup is both fast and convenient. See the {Configurable}[http://tap.rubyforge.org/configurable]
documentation for more information.

==== {Configurable::Validation}[http://tap.rubyforge.org/configurable/classes/Configurable/Validation.html]

When configurations are set from the command line, the config writer inevitably
receives a string, even though you may want a non-string input.  The
{Validation}[http://tap.rubyforge.org/configurable/classes/Configurable/Validation.html]
module provides standard blocks for validating and transforming inputs, and
may be accessed through the shortcut method <tt>c</tt> (ex: <tt>c.integer</tt>
or <tt>c.regexp</tt>).  Validation blocks (generally) load string inputs as
YAML and validate that the result is the correct class; non-string inputs are
simply validated.

  class ValidatingClass
    include Configurable

    config :int, 1, &c.integer                 # assures the input is an integer
    config :int_or_nil, 1, &c.integer_or_nil   # integer or nil only
    config :array, [], &c.array                # you get the idea
  end

  vc = ValidatingClass.new

  vc.array = [:a, :b, :c]
  vc.array                                     # => [:a, :b, :c]

  vc.array = "[1, 2, 3]"
  vc.array                                     # => [1, 2, 3]

  vc.array = "string"                          # !> ValidationError

Validation blocks sometimes imply metadata.  For instance <tt>c.flag</tt> makes
a config into a flag on the command line.

==== {Lazydoc}[http://tap.rubyforge.org/lazydoc]

{Lazydoc}[http://tap.rubyforge.org/lazydoc] fits into the space between live
code and code documentation.  Lazydoc can scan a file and pull documentation
into the object space, typically via a syntax like this:

  # Constant::key value
  # comment

For example:

  [lazydoc_file.rb]
  # Const::Name::key value
  # 
  # This is an extended,
  # multiline comment.
  #

  require 'tap'

  lazydoc = Lazydoc[__FILE__]
  lazydoc.resolve
  
  lazydoc['Const::Name']['key'].value          # => "value"
  lazydoc['Const::Name']['key'].comment        # => "This is an extended, multiline comment."

Lazydoc can also register specific lines for documentation, like method
definitions or configurations.  Tap uses Lazydoc to identify files that contain
tasks and generators, to extract config documentation, and to infer the args
arguments a task receives.  Here is an example of information gleaned from a
task definition:

  # Sample::manifest a summary of the task
  class Sample < Tap::Task
    config :key, 'value'   # a simple configuration
    
    def process(a, b='B', *c)
    end
  end
  
  Sample::manifest.to_s                        # => "a summary of the task"
  Sample::args.to_s                            # => "A B='B' C..."
  
  key = Sample.configurations[:key]
  key.attributes[:desc].to_s                   # => "a simple configuration"
  
See the {Lazydoc}[http://tap.rubyforge.org/lazydoc] documentation for more
information.

=== Tap::Task

http://tap.rubyforge.org/images/Task.png

Tasks are the bread and butter of Tap.  Tasks act as the nodes in workflows and,
using the Configurable and Lazydoc metadata, map to the command line as miniature
applications.  That said, tasks are perfectly useful as ordinary objects.

When subclassing is too much, tasks may be interned with a block that effectively
replaces <tt>process</tt>:

  t = Tap::Task.intern {|task| 1 + 2 }
  t.process                # => 3

  t = Tap::Task.intern {|task, x, y| x + y }
  t.process(1, 2)          # => 3

Tasks can be configured,

  runlist = []
  t1 = Tap::Task.intern(:key => 'one') do |task, input| 
    runlist << task
    "#{input}:#{task.config[:key]}"
  end

joined into dependency-based workflows,

  t0 = Tap::Task.intern {|task| runlist << task }
  t1.depends_on(t0)

and imperative workflows.

  t2 = Tap::Task.intern do |task, input|
    runlist << task
    "#{input}:two"
  end
  t1.sequence(t2)
  
Results are aggregated into the underlying Tap::App.

  t1.enq('input')
  
  app = Tap::App.instance
  app.run
  
  runlist                  # => [t0, t1, t2]
  app.results(t2)          # => ["input:one:two"]

Tracking the evolution of a result through a workflow can get complex.  Tap
audits workflows to help.  Setting the names of the tasks will identify them
in an audit dump:

  t1.name = 'un'
  t2.name = 'deux'
  
  app._results(t2)[0].dump
  # => 
  # o-[] "input"
  # o-[un] "input:one"
  # o-[deux] "input:one:two"

== Apps

==== Tap::Root

http://tap.rubyforge.org/images/Root.png

A Root represents the base of a directory structure. Roots allow you to alias
relative paths, basically allowing you to develop code for a conceptual
directory structure that can be defined later.

  root = Tap::Root.new '/path/to/root'
  root.root                                      # => '/path/to/root'
  root['config']                                 # => '/path/to/root/config'
  root.filepath('config', 'sample.yml')          # => '/path/to/root/config/sample.yml'

While simple, this ability to alias paths is useful, powerful, and forms the
basis of the Tap execution environment.

==== Tap::Support::ExecutableQueue

http://tap.rubyforge.org/images/ExecutableQueue.png

Apps coordinate the execution of tasks through a queue.  The queue is just a
stack of Executable objects, basically methods, and the inputs to those 
methods; during a run the enqued methods are sequentially executed with the 
inputs.

=== Tap::App

http://tap.rubyforge.org/images/App.png

Instances of Tap::App coordinate the execution of tasks.

Task initialization requires an App, which is by default Tap::App.instance.  
Tasks use their app for logging, dependency-resolution, checks, and to enque 
themselves.  Normally a script will only need and use a single instance (often
Tap::App.instance), but there is no reason why multiple instances could not be
used.  

  log = StringIO.new
  app = Tap::App.instance
  app.logger = Logger.new(log)
  app.logger.formatter = lambda do |severity, time, progname, msg|
    "  %s %s: %s\n" % [severity[0,1], progname, msg]
  end
  
  t = Tap::Task.intern {|task, *inputs| inputs }
  t.log 'action', 'to app'
  log.string                 # =>  "  I action: to app\n"
  
  t.enq(1)
  t.enq(2,3)
  
  app.queue.to_a             # => [[t, [1]], [t, [2,3]]]
  app.run
  app.results(t)             # => [[1], [2,3]]
  
As shown, apps also aggregate results for tasks, which is important for
divergent workflows.

== Envs 

==== Tap::Env

http://tap.rubyforge.org/images/Env.png

Envs generate manifests of various resources (tasks, generators, etc) and 
provide methods to uniquely identify resources using minimized base paths.
In this directory structure:

  path
  `- to
      |- another
      |   `- file.rb
      |- file-0.1.0.rb
      |- file-0.2.0.rb
      `- file.rb

The minimal paths that uniquely identify these files are (respectively):

  'another/file'
  'file-0.1.0'
  'file-0.2.0'
  'file.rb'

Envs facilitate mapping a minimal path to an actual path, and hence to a
resource.  Envs can be nested so that manifests span multiple directories.
Indeed, this is how tap accesses tasks and generators within gems; the gem
directories are initialized as Envs and nested within the Env for the working
directory.

http://tap.rubyforge.org/images/Nested-Env.png

To prevent conflicts between similarly-named resources under different Envs,
Env allows selection of Envs, also by minimized paths.  Say you installed the
'sample_tasks' gem.

  % tap manifest
  --------------------------------------------------------------------------------
  Desktop:           (/Users/username/Desktop)
  --------------------------------------------------------------------------------
  sample_tasks:      (/Library/Ruby/Gems/1.8/gems/sample_tasks-0.10.0)
    tasks
      concat         (lib/tap/tasks/concat.rb)
      copy           (lib/tap/tasks/copy.rb)
      grep           (lib/tap/tasks/grep.rb)
      print_tree     (lib/tap/tasks/print_tree.rb)
  --------------------------------------------------------------------------------
  tap:               (/Library/Ruby/Gems/1.8/gems/tap-0.10.8)
    generators
      command        (lib/tap/generator/generators/command/command_generator.rb)
      config         (lib/tap/generator/generators/config/config_generator.rb)
      file_task      (lib/tap/generator/generators/file_task/file_task_generator.rb)
      generator      (lib/tap/generator/generators/generator/generator_generator.rb)
      root           (lib/tap/generator/generators/root/root_generator.rb)
      task           (lib/tap/generator/generators/task/task_generator.rb)
    commands
      console        (cmd/console.rb)
      destroy        (cmd/destroy.rb)
      generate       (cmd/generate.rb)
      manifest       (cmd/manifest.rb)
      run            (cmd/run.rb)
      server         (cmd/server.rb)
    tasks
      dump           (lib/tap/tasks/dump.rb)
      load           (lib/tap/tasks/load.rb)
      rake           (lib/tap/tasks/rake.rb)
  --------------------------------------------------------------------------------

  Desktop
  |- sample_tasks 
  `- tap 

In this printout of the manifest, you can see the resources available to tap on
the Desktop (none), in the sample_tasks gem, and in tap itself.  Since there
aren't any conflicts among tasks, the minipath of any of the tasks is sufficient
for identification:

  % tap run -- print_tree
  % tap run -- dump
  
If there were a conflict, you'd have to specify the environment minipath like:

  % tap run -- sample_tasks:print_tree
  % tap run -- tap:dump

==== Tap::Exe

http://tap.rubyforge.org/images/Run-Env.png

Tap::Exe adds several configurations (ex before/after) which only get loaded
for the present directory, and methods for building and executing workflows
from command line inputs.
