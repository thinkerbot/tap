#############################################
# HOW TO PACKAGE YOUR SCRIPT:
# 1. Attend to the parts marked TODO
# 2. Run rubyscript2exe as described below:
#
#   % rubyscript2exe package/<%= package_file %>.rb
#
# NOTES:
# The 'rubyscript2exe' gem is required for packaging -- install using:
#    % gem install rubyscript2exe
#
# The inputs you used when creating this script will supplied before 
# the inputs you provide to the executable.  Hence if you used:
#    % tap generate package "run --quiet some/task"
#
# These will be equivalent commands:
#    % tap run --quiet some/task INPUT1 INPUT2
#    % <%= package_file %>.exe INPUT1 INPUT2
#
# Feel free to adjust this script to behave as you like -- whatever this 
# script does will be packaged into the executable. 
#
#############################################
#
# = Prompt Instructions
# Enter inputs or an empty line to execute.

require "tap"
require "tap/env"
require "tap/script"

# require "tap/support/tdoc"

# = TODO: add script requires
# Only what this script does will be packaged into the executable.
# You MUST specify tasks and other files that are not loaded during
# the 'rubyscript2exe' execution of this script.  Usually this means
# require-ing any tasks that may get used.
# 
# require 'some/task'

app = Tap::App.instance

# = TODO: check arguments
# Make sure these are what you want later in this script they're unshifted
# onto ARGV, ie they'll be hard-coded into the executable.
cmd_argv = <%= argv %>

# = TODO: check configurations
# This configures the packaged app the same as the current tap.yml
env_config_str = %Q{<%= config %>}

env_config = YAML.load(ERB.new(env_config_str).result)
env_config = case env_config
when Hash then env_config
when nil, false then {}
else
  raise "env configs did not load to a hash"
end

# = TODO: decide if you want to prompt when you get no inputs
# This can be handy if you want to be able to interact with the 
# packaged script.
if ARGV.select {|arg| arg !~ /^-|^--/ }.empty?
  puts Tap::Script.usage(__FILE__, "Prompt Instructions", :keep_headers => false)

  while true
    print "input: "
    line = gets.strip
    break if line.empty?
    
    line = line[1..-2] if line =~ /^".*"$/
    ARGV << line
  end
  puts
end

# nice to give the user a prompt before you exit
def exit(*args)
	puts 
	puts "Hit enter to exit."
  ARGV.clear
	gets
	super
end

#############################################
# These sections generally needs far less customization
#############################################
require 'tap/support/package'

env = Tap::Env.instance
before = nil
after = nil

def handle_error(err)
  case
  when $DEBUG
    puts err.message
    puts
    puts err.backtrace
  when Tap::App.instance.debug? then raise err
  else puts err.message
  end
end

# configure the app
#
begin
  env.configure(env_config) do |app, config|
    before = config.delete('before')
    after = config.delete('after')
    
    app.reconfigure(config)
  end
rescue(Exception)
  # catch errors and exit gracefully
  # (errors usu from gem loading errors)
  puts "Configuration error: #{$!.message}"
  exit(1)
end

#
# run before script
#
begin
  eval(before.to_s)
rescue
  puts "Error in before script."
  handle_error($!)
  exit(1)
end

# This is where the inputs used to create this script are unshifted
# onto ARGV, ahead of the user inputs.  
cmd_argv.reverse_each  {|arg| ARGV.unshift arg}
if cmd_argv.empty?
  puts "Malconfigured package: No command specified."
  exit(1)
end

#
# run the script -- note that the first argument
# to ARGV is the script that gets run.
#
begin
  load env.commands[ARGV.shift]
rescue
  handle_error($!)
end

#
# run after script
#
begin
  eval(after.to_s) 
rescue
  puts "Error in after script."
  handle_error($!)
  exit(1)
end

exit(0)