require 'tap/root'
require 'tap/support/configurable'
autoload(:Dependencies, 'tap/support/dependencies')
require 'strscan'

module Tap
  class Env
    include Support::Configurable
    @@instance = nil
    @@instances = {}

    class << self  
      # Returns the active instance of Env.
      def instance
        @@instance
      end

      # A hash of (path, Env instance) pairs, generated by Env#instantiate.  Used
      # to prevent infinite loops of Env dependencies by assigning a single Env
      # to a given path.
      def instances
        @@instances
      end
      
      # Creates a new Env for the specified path and adds it to Env#instances, or 
      # returns the existing instance for the path.  Paths can point to an env config
      # file, or to a directory.  If a directory is provided, instantiate treats
      # path as the DEFAULT_CONFIG_FILE in that directory. All paths are expanded.
      #
      #   e1 = Env.instantiate("./path/to/config.yml")
      #   e2 = Env.instantiate("./path/to/dir")
      #
      #   Env.instances       
      #   # => {
      #   #  File.expand_path("./path/to/config.yml") => e1, 
      #   #  File.expand_path("./path/to/dir/#{Tap::Env::DEFAULT_CONFIG_FILE}") => e2 }
      #
      # The Env is initialized using configurations read from the env config file using
      # read_config, and a Root initialized to the config file directory. An instance 
      # will be initialized regardless of whether the config file or directory exists.
      def instantiate(path)
        if File.directory?(path) || (!File.exists?(path) && File.extname(path) == "")
          path = File.join(path, DEFAULT_CONFIG_FILE) 
        end
        path = File.expand_path(path)
        
        # return the existing instance if possible
        return instances[path] if instances.has_key?(path)
        
        # note the assignment of env to instances MUST occur before
        # reconfigure to prevent infinite looping
        (instances[path] = Env.new({}, Root.new(File.dirname(path)))).reconfigure(read_config(path))
      end
      
      # Templates the input filepath using ERB then loads it as YAML.  
      # Returns an empty hash if the file doesn't exist, or loads to
      # nil or false (as for an empty file).  Raises an error if the
      # filepath doesn't load to a hash.
      def read_config(filepath)
        return {} if !File.exists?(filepath) || File.directory?(filepath)

        input = ERB.new(File.read(filepath)).result
        config = YAML.load(input)

        case config
        when Hash then config
        when nil, false then {}
        else
          raise "expected hash from config file: #{filepath}"
        end
      end

      # Returns the full_gem_path for the specified gem.  A gem version 
      # can be specified in the name, like 'gem >= 1.2'.  The gem will
      # be activated using +gem+ unless already active.
      def full_gem_path(gem_name)

        # figure the version of the gem, by default >= 0.0.0
        gem_name =~ /^([^<=>]*)(.*)$/
        name, version = $1.strip, $2
        version = ">= 0.0.0" if version.empty?

        # load the gem and get the spec
        gem(name, version)
        spec = Gem.loaded_specs[name]

        if spec == nil
          log(:warn, "unknown gem: #{gem_name}", Logger::WARN)
        end

        spec.full_gem_path
      end
      
      protected
      
      def path_config(key, value=[]) 
        instance_variable = "@#{key}".to_sym
        config_attr(key, value) do |input|
          check_paths_configurable
          instance_variable_set(instance_variable, [*input].compact.collect {|path| root[path]}.uniq)
        end
      end
      
    end
    
    # The default config file path
    DEFAULT_CONFIG_FILE = "tap.yml"
    
    # Returns a list of arrays that receive load_paths on activate,
    # by default [$LOAD_PATH]. If use_dependencies == true, then
    # Dependencies.load_paths will also be included.
    attr_accessor :load_path_targets
    
    attr_reader :root
    
    # Gets or sets the logger for self
    attr_accessor :logger
    
    # An array of nested Envs
    attr_reader :envs
    
    # Specify env configuration files used to instantiate nested Envs.
    config_attr :env_paths, [] do |input|
      check_paths_configurable
      
      @envs = [*input].compact.collect {|path| Env.instantiate(root[path]) }.uniq
      @env_paths = envs.collect {|e| e.env_path }
    end
    
    # Designate load paths.  If use_dependencies == true, then
    # load_paths will be used for automatic loading of modules
    # through the active_support Dependencies module.
    path_config :load_paths, ["lib"]
    
    # Designate paths for discovering and executing commands. 
    path_config :command_paths, ["cmd"]
    
    # Designate paths for discovering generators.  
    path_config :generator_paths, ["lib/generators"]
    
    def initialize(config={}, root=Tap::Root.new, logger=nil)
      @root = root 
      @logger = logger
      @load_path_targets = [$LOAD_PATH]
      @envs = []
      @active = false
      initialize_config(config)
    end
    
    def reconfigure(overrides={})
      # partiton config into its parts
      env_configs = {}
      root_configs = {}
      other_configs = {}
      
      env_configurations = self.class.configurations
      root_configurations = root.class.configurations
      overrides.each_pair do |key, value|
        key = key.to_sym
    
        partition = case 
        when env_configurations.key?(key) then env_configs
        when root_configurations.key?(key) then root_configs
        else other_configs
        end
    
        partition[key] = value
      end
    
      # reconfigure root so it can resolve paths in env
      root.reconfigure(root_configs)
      super(env_configs)
      
      # handle unknown configs 
      case
      when block_given?
        yield(other_configs) 
      when !other_configs.empty?
        log(:warn, "ignoring non-env configs: #{other_configs.keys.join(',')}", Logger::DEBUG)
      end
      
      self
    end
    
    # Returns the path for self in Env.instances.
    def env_path
      paths = Env.instances.select {|key, env| env == self }
      case paths.length
      when 0 then nil
      when 1 then paths[0][0]
      else raise "multiple paths key '#{self}' in Env.instances!"
      end
    end
    
    # Logs the action and message at the input level (default INFO).
    # Logging is suppressed if no logger is set.
    def log(action, msg="", level=Logger::INFO)
      logger.add(level, msg, action.to_s) if logger
    end
    
    # Activates self by unshifting load_paths for self to the load_path_targets.
    # Once active, self can be referenced from Env.instance and the current
    # configurations are frozen.  Env.instance is deactivated, if set, before
    # self is activated. Returns true if activate succeeded, or false if self 
    # is already active.
    def activate
      return false if active?
      
      @active = true
      @@instance = self unless @@instance
      
      # activate nested envs
      envs.reverse_each do |env|
        env.activate
      end

      # freeze array configs like load_paths
      config.each_pair do |key, value|
        case value
        when Array then value.freeze
        end
      end
    
      # add load paths to load_path_targets
      load_path_targets.each do |target|
        load_paths.reverse_each do |path|
          target.unshift(path)
        end
    
        target.uniq!
      end
    
      true
    end
    
    # Deactivates self by deleting load_paths for self from the load_path_targets.
    # Env.instance will no longer reference self and the configurations are 
    # unfrozen (using duplication as needed, but it amounts to the same thing).
    # Returns true if deactivate succeeded, or false if self is not active.
    def deactivate
      return false unless active?
      
      # remove load paths from load_path_targets
      load_path_targets.each do |target|
        load_paths.each do |path|
          target.delete(path)
        end
      end
      
      # unfreeze array configs by duplicating
      self.config.class_config.each_pair do |key, value|
        value = send(key)
        case value
        when Array then instance_variable_set("@#{key}", value.dup)
        end
      end
      
      @active = false
      @@instance = nil if @@instance == self
      
      # dectivate nested envs
      envs.reverse_each do |env|
        env.deactivate
      end
      
      true
    end
    
    # Return true if self has been activated.
    def active?
      @active
    end
    
    #
    # Under construction
    #
    
    def debug_setup
      $DEBUG = true
      logger.level = Logger::DEBUG if logger
    end

    def handle_error(err)
      case
      when $DEBUG
        puts err.message
        puts
        puts err.backtrace
      when debug then raise err
      else puts err.message
      end
    end
    
    protected
    
    def check_paths_configurable
      raise "path configurations are disabled when active" if active?
    end
  end
end